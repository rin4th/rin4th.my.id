---
title: Golang Basic
date: 2023-08-29
description: golang basic such as looping, interface, pointer, etc.
page: 2
---
import Note from "~/components/Note.astro"


# Data type
## Array
Array is a collection of elements that belong to the same type. The elements of an array are stored sequentially in memory.
```go
// Create array
var array_name = [length]datatype{values}

// Access array
fmt.Println(array_name[index])

// Assgin value 
array_name[index] = value
```
## Slice
Slice is a segment of an array. Like arrays slices are indexable and have a length. The length of a slice is the number of elements it contains. The capacity of a slice is the number of elements in the underlying array, counting from the first element in the slice.
```go
// Create slice
slice_name := make([]type, length, capacity)

// Modify slice
slice_name = append(slice_name, value)

// Copy slice
copy(slice_name, slice_name2)
```

## Map
Map is a collection of key-value pairs. Maps are also known as hash tables, dictionaries, or associative arrays in other languages.
```go
// Create map
map_name := make(map[key_type]value_type)

// Modify map
map_name[key] = value

// Delete map
delete(map_name, key)

// Check map
value, ok := map_name[key]
``` 

## Struct
Struct is a collection of fields. It is useful for grouping data together to form records.
```go
// Create struct
type struct_name struct {
    field_name1 type
    field_name2 type
}

// Assign value
var_name := struct_name{
    field_name1: value1,
    field_name2: value2
    }

// Access value
fmt.Println(var_name.field_name1)
```

# Condition
In golang to define condition we can use if else or switch case.
```go
// if else
if condition {
    // do something
} else {
    // do something
}

// switch case
switch condition {
case condition1:
    // do something
case condition2:
    // do something
default:
    // do something
}
```

# Looping
In golang to define looping you only can use for loop. But you can use for loop as while loop.
```go
// for loop
for i := 0; i < 10; i++ {
    fmt.Println(i)
}

// while loop
i := 0
for i < 10 {
    fmt.Println(i)
    i++
}
```

# Function
Function in golang have many type such as normal function, return function, variadic function, and anonymous function.
## Return function
```go
// Create function
func function_name(parameter1 type, parameter2 type) return_type {
    // do something
    return return_value
}

// Call function
var_name := function_name(parameter1, parameter2)
```

## Variadic function
variadic function is function that can accept variable number of arguments. The function can accept zero or more arguments.

```go
// Create function
func function_name(parameter ...type) return_type {
    // do something
    return return_value
}

// Call function
var_name := function_name(parameter1, parameter2)
```

## Anonymous function
anonymous function is function that doesn't have name. It is useful when you want to define a function inline without having to name it.

```go
// Create anonymous function
var := func(parameter1 type, parameter2 type) return_type {
    // do something
    return return_value
}
// Call anonymous function
var_name := var(parameter1, parameter2)
```


# Pointer
Pointer is a variable that stores the memory address of another variable. They are useful when you want to pass a large struct to a function without copying the struct.
```go
// Create pointer
var var_name *type

// Assign value
var_name = &value

// Access value
fmt.Println(*var_name)
```

# Interface
Interface is datatype abstract. Interface is a set of method signature. When a type provides definition for all the methods in the interface, it is said to implement the interface.

```go
// Create interface
type interface_name interface {
    method_name1() return_type
    method_name2() return_type
}

// Create struct
type struct_name struct {
    field_name1 type
    field_name2 type
}

// Implement interface
func (var_name struct_name) method_name1() return_type {
    // do something
    return return_value
}

// Call interface
var_name := struct_name{
    field_name1: value1,
    field_name2: value2
    }
var_name.method_name1()
var_name.method_name2()
```


